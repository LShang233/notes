# 闭包

## 1、什么是「闭包」。

**有权访问另一个函数作用域中  的  变量  的  函数**

方式就是在一个函数内创建另一个函数，内部函数可以访问到外部函数中的变量



**特性：**

1. 函数再嵌套
2. 参数和变量不会被垃圾回收机制回收
3. 内部函数可以引用外部函数的参数和变量



## 2、「闭包」的作用是什么。

**作用：**

1. 可以在函数的外部访问到函数内部的局部变量。 （隐藏变量
2. 让这些变量始终保存在内存中，不会随着函数的结束而自动销毁

**经典问题**：

https://www.cnblogs.com/princeness/p/11664978.html

多个子函数的[[scope]]都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。

**解决：**

变量可以通过 函数参数的形式 传入，避免使用默认的[[scope]]向上查找 

使用setTimeout包裹，通过第三个参数传入 

使用 块级作用域，让变量成为自己上下文的属性，避免共享



## 3、闭包的垃圾回收机制

主要使用标记清理和引用计数两种方法

最常用的就是**标记清理**，当函数内部声明一个变量的时候，会加上一个标记，当变量离开上下文的时候，也会被加上离开的标记

当垃圾回收机制运行的时候，会标记内存中存储的所有变量，然后，将所有上下文中的变量，以及被上下文中的变量引用的变量标记去掉，剩下还有标记的变量则表示任何在上下文中的变量都访问不到了

随后进行内存清理

另一种**引用计数**，思路是对每个值都记录他被引用的次数

声明时引用数为1，如果被赋值给其他变量，则加一

同样，如果被覆盖，则减一

当一个数的引用数为0的时候，表示已经没法访问到这个值了

但他有一个**问题**，那就是循环引用，这样引用数永远不会变为0

需要在确保不使用的情况下切断链接

**周期**

垃圾回收机制会周期性运行，下一次运行的时候根据浏览器会有不一样的策略

但基本上都是根据活跃对象的数量和一些余量来确定何时再次启动

### 内存管理

将内存占用量保持在一个较小的值可以让页面性能更好

1. 使用const和let。因为作用域是块级，方便让垃圾回收检测到
2. 避免“先创建再补充”式的动态属性赋值，并在构造函数中一次性声明所有属性
3. 避免内存泄漏
4. 减少垃圾回收的次数

## 4、闭包的this

如果内部函数没有使用箭头函数定义，则this对象会在运行时绑定到执行函数的上下文

```js
window.a = '1'
let o = {
    a: 'a',
    fun1() {
        return function() {return this.a}
    },
    fun2() {
        // 这里的this是o
        console.log(this)
        return () => {return this.a} // 这里的this是func2的this
    },
    fun3: () => {
        console.log(this) // this已经确定了，是window（o.fun3的上下文）
        return function() {return this.a}
    }
}
console.log(o.fun1()()) // 1
console.log(o.fun2()()) // a
console.log(o.fun3()()) // 1
```

