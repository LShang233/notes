# for-of与for-in

for-in是es6之前就出现的

1. 他遍历可枚举对象的**属性**，同时上也会遍历**原型**上的属性和方法
2. 并不支持set和map的遍历，
3. 他是一个**无序**的遍历，会因为浏览器的不同而导致遍历顺序不同
4. 他会**跳过**`null`和`undefined`

for-of的出现解决了for-in的问题

1. 首先他会遍历可迭代对象的**元素**，
2. 他的遍历顺序是对象next（）方法返回的顺序，所以在不同浏览器上都是一样的
3. 他支持遍历set和map，而且她不会跳过空值

# 箭头函数

箭头函数是ES6新出的函数，他包含普通函数的绝大多数功能

除了一下语法上的区别，他和普通函数还有一些其他的区别

1. 他没有arguments、new.target、super
   1. 但他可以用**收集参数**的方法获取arguments（...values）
   2. 也可也外层再嵌套一个普通函数来收集
2. 他不能用能用作构造函数，所以他也没有prototype属性
3. 不能作为generator函数，没有yield
4. 普通函数的this是指向调用这个函数对象，而箭头函数的this是指向定义这个函数的环境的；
   - 这是因为普通函数是在使用这个函数的时候，才创建的this
   - 而箭头函数他自己是没有this属性的，所以需要通过作用域链来找到自己的this，而除了函数，其他类型变量对象都是在定义的时候就生成的



# promise原理

之前只支持定义回调函数来表明异步操作完成，需要串联多个异步操作，通常需要深度嵌套回调函数（回调地狱），为了解决这个问题，出现了Promise（期约）



promise主要分为三个功能模块

1. promise定义
2. then的执行
3. resolve和reject的处理

首先，promise对象的定义和初始化

他有几个参数，分别保存当前状态，当前返回值，还要保存resolve和reject的处理方法

而且自身还要有resolve、reject、then等方法

而且状态分为pending，fulfilled，rejected三个状态，而且只能从pending转为其他两个状态



然后是then的执行

首先将两个回调封装到handler对象中，再把handler对象挂在当前的的promise内



此时promise已经封装好了，而且已经调用了then处理回调，等待函数执行到resolve或reject

如果函数实行到了reject，说明函数执行失败了，这个时候需要调用对象中保存的失败的回调函数，并把promise对象的状态改为失败，传入失败原因

如果函数执行到了resolve，说明函数执行成功，但此时又分为几种情况

1. 如果resolve里面的值是promise对象，就把resolve的回调函数执行，并把里面的返回值作为下一个promise对象的value，
2. 如果是其他对象，就只用把里面的回调函数执行



所以，无论是哪种情况，都需要处理自己的回调

这个函数还在then的时候使用过

所以要分为两种情况：

1. 当状态为pending的时候，将回调存储
2. 其他状态的时候，执行回调



# 手写promise代码

# 你知道generator吗

generator函数的表示符是在函数名前加*号，当函数内部遇见yield标识符时候，会交出函数的**执行权**，直到调用next方法后才会继续行动

生成器可以自定义迭代器和实现协程，每次迭代都会返回一个对象，里面包含done和value属性，done为true表示已经不可迭代了，而value是yield后面的参数运行后的结果

# 讲讲async/await

async让函数具有异步特性，但他的代码还是同步求值的，所以如果没有使用await，他相当于一个同步函数

那如果遇见了await，则会暂停函数，异步**执行**，直到异步函数执行完成后才会继续执行（await后的执行，后面的暂停）

而如果使用return或者await返回了值，这个值会promise.resolve包装成promise对象，没有return则返回undefined



1. async本质上是个Generator函数的语法糖。例如async代替*
2. async内置执行器
3. 比Generator有更好的语法，我们Generator函数里面的异步操作，如果需要自动执行，那么就要是一个thunk函数或者返回promise对象。async不需要
4. await代替yield命令，await命令本质上就是内部的then函数



# 闭包，闭包的问题

有权访问另一个函数作用域中的变量 的函数，称为闭包

通常是使用函数内部嵌套另一函数实现的，内部函数能访问到外部函数变量

因为闭包不会被垃圾回收机制回收，所以他可以读取函数内部的变量，并把它保存在内存中

他也就可以封装对象的私有属性

优点是可以实现**封装和缓存**，但同时，也会消耗内存，不当的时候甚至会造成内存泄漏



闭包里面多个子函数默认是通过[[scope]]向上查找的，所以当父级修改的时候，所有子函数都会受到影响

解决的方法就是隔开作用域，可以通过函数传参、使用settimeout用第三方数据传入、或者使用块级作用域隔开



# 垃圾回收

引用计数、标记删除（常用）

# 手写async

# this

# settimeout的第三个参数是什么
