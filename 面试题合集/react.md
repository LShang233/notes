## 讲讲react

react作为一个前端的框架，其目的是为了让前端项目的编写和维护更加容易



##  事件代理 

将事件全部绑定到最外层的结构上，使用一个统一的事件监听器

当函数挂载或者卸载的时候，这个监听器会删除和插入一些对象

当事件发生的时候，会被监听器拦截，然后再映射表中找到真正的处理函数并且调用

优点。

1. 减少事件注册,节省内存，能够提升整体性能。
2. 简化了dom节点更新时,相应事件的更新（用过 jquery 的都知道，动态加入的元素，事件需要重新绑定）。

# 类组件和函数组件

## 1、区别

首先类组件会通过new去创建，会形成一个实例对象，而函数组件本质上是一个函数

所以类组件有自己的this，而函数组件没有，

所以，类组件可以使用自己的实例来存放状态，也就可以去存放一些生命周期函数

而函数组件没有实例来存放状态，所以需要借助fiber节点的memorizedState属性进行存放





#  虚拟dom 

## 1、讲讲虚拟dom

1. 真实dom元素非常庞大，频繁的修改会产生很大的开销
2. 于是很多框架采用虚拟dom，通过维护虚拟dom来减少真实dom的操作
3. 采用虚拟dom还可以在转化为真实dom的过程中进行许多的操作，如添加生命周期钩子，比较虚拟dom的不同来减少对真实dom的操作，还可以将一次大的修改分割为多次小修改，以此避免让用户察觉到页面卡顿
4. 他还有一个好处，他抽象了渲染的过程，为引用带来了跨平台的能力



#  setstate

##  1、具体过程 

进入setState后，会先判断isBatchingUpdates

若开启，则将数据放入队列

若未开启，则依次进行队列里的操作，进行数据更新



在react的合成事件和钩子函数中，进行了wrapper封装，一个`wrapper`包含一对 `initialize` 和 `close` 方法

在initialize中开启，在close中关闭



## 2、setstate同步还是异步

`setState`只在**合成事件和钩子函数**中是“异步”的，在原生事件和 `setTimeout` 中都是同步的。

` setState`的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 `setState(partialState, callback)` 中的`callback`拿到更新后的结果。

`setState` 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和`setTimeout` 中不会批量更新，在“异步”中如果对**同一个值**进行多次 `setState `， `setState` 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是**同时 `setState` 多个不同的值**，在更新时会对其进行合并批量更新。



# diff

## 1、讲讲diff算法

首先diff算法有几个前提：

因为完全比较会消耗很大的时间和资源，需要On3的复杂度，所以diff的前提是同层级间比较

同时，如果当前节点不可复用，那么他的子节点也不可复用

**分为单节点和多节点**

1、单节点

- 是否有对用的真实dom
- 是否key相同
- 是否type相同

不通过打上创建新节点，如果有真实dom还要讲旧节点打上delete

2、多节点

根据实际开发的情况下，修改操作远大于其他操作，将diff分为两步

1. 查找修改的节点
   - 与单节点相同，如果出现key不同的情况，则说明有节点发生移动，退出遍历
2. 剩余节点
   - 根据新旧树剩余节点的数量分为四种情况
   - 任意有一棵树是空的话，剩余节点都打上创建或删除的标记
   - 两棵树都不为空，则要进行比对，找到可复用的节点
     - 维护最后一个可复用节点的下标，每次比对都从这个下标往后查找
     - 这个造成的后果就是dom节点只能往后移动
     - 也就是说，最后一个节点移动最前端的时候，需要将前面所有节点向后移
     - 这也是diff的缺陷



## 2、缺陷

vue借鉴了react的diff并做出了优化

从2.x开始，vue2使用的是头尾两头一起查找，其他与react多节点diff相同



vue3的diff3在2的基础上多了一步工序

他多消耗了nlogn的时间复杂度，使用了查找最长递增子序列的方式，找到最长可复用节点

![image-20220613115401120](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20220613115401.png)

![image-20220613115424129](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20220613115424.png)





# Hooks

## 1、讲讲hooks

- 是函数式组件独有的，他是函数式组件的申明周期函数和状态
- 拿useState举例，分为mount和update阶段
- mount时会将useState封装一个hook对象，挂到FiberNode的memoriseState上，它是一个单链表，存了所有的hook
- 这个hook对象上有一个queue属性，保存了你这个useSate的所有状态，它是一个循环链表，指向最新更新的状态
- 当你在update的时候，会顺着memoriseState找到你需要的hook，然后获取最新的状态；
- 如果是useReducer的话，他跟useState的区别是，useState存的是数据，而他存的是函数，
- 所以，她或通过queue.next获取第一次更新的操作，然后依次执行，最后返回函数执行的结果；
- 如果是useEffert的话，他的状态是存在FiberNode的updateQueue上的，每次执行的时候会先判断他的依赖有没有改变，如果为改变的话会跳过更新

## 2、useCallback和useMemo的区别：

- `mountMemo`会将`回调函数`(nextCreate)的**执行结果**作为`value`保存
- `mountCallback`会将`回调函数`作为`value`保存



1、useMemo：解决的是：防止无效函数**调用**

2、useCallback：解决的是：防止无效函数**定义**



# redux

##  redux原理 

- redux是将整个应用的状态存储到一个地方，称为store
- 里面保存着一颗状态树
- 组件可以dispatch action给store
- store将旧数据和action交给reducer处理，reducer将更新好的新数据返回给store
- 其他组件可以通过getState获取store里的数据
- 
- 所以，redux有三个重要的模块，分别是action、store、reducer
- action负责将用户的操作派发给store
- store是只读的，他将旧数据和行为包装，发给reducer
- reducer处理之后，将新数据交还给store存储
- 
- 这里有几点要注意
- 首先：redux是单一数据源，也就是说，store是唯一的
- 第二：store只读，他不负责处理数据，处理数据的操作都交给reducer
- 最后：reducer是一个纯函数，也就是说你可以拆分成很多个小reducer，分别处理状态树的不同数据
- 还有一点：reducer返回的数据会覆盖原值，也就是说，如果是数组，你需要将新数据和之前的数据一起返回

















