## 锁分为哪几种？

互斥锁、读写锁、条件变量（以源子的方式阻塞进程）、自旋锁。

自旋锁：线程受限时不阻塞，而是不断轮询。由于没有线程的切换，所以不会产生太大的开销。



## 并发和并行的区别？

并发指的是一段时间内，多个任务都会被处理，一般是用于单核，每个任务分配到一定的时间片进行执行。

并行指的是同一时间，多个任务同时执行，只能在多核实现。



## 内存中堆和栈的区别？

- 栈：由操作系统自动释放，存放函数的参数、局部变量等，数据结构类似于栈。
- 堆：由开发者手动释放，等到程序结束时，OS也会全部释放，分配方式类似于链表。
- 主要的区别：
  1. 管理方式不同：栈自动回收，堆需要手动回收。
  2. 大小不同：堆的内存空间要远大于栈。
  3. 生长方向不同：堆向上生长，地址由低到高；栈向下生长，地址由高到低。
  4. 分配方式不同：堆都是动态分配的；栈可以是静态分配，即由操作系统默认分配，也可以是动态分配，不过都由操作系统自动回收。
  5. 分配效率不同：堆需要用户手动申请和释放，容易产生内碎片；栈有专门的寄存器存放栈的地址，也有专门的指令。
  6. 存放内容不同：栈一般存放函数的参数、局部变量等暂时性的内容；堆一般存放程序员自定义的内容，存活时间较长。

# 系统内核

## 什么是系统内核？

系统内核就是一些和硬件紧密相关的模块，如各式各样的驱动程序或者一些系统调用。这些模块安排在靠近硬件的软件层次中，常驻内存。



## 什么是内核态和用户态？

内核态又称为管态，能够执行底层指令和访问所有存储区和内存。

用户态的权限较少，只能执行特定的指令来调用系统指令，能够访问的内存区域也有限。

这样区分是对用户的权限进行限制，防止用户随意访问系统的部分内核数据导致系统崩坏。



## 操作系统的启动过程是什么样的？

- 首先是BIOS自检，BIOS是基本输入输出系统，固化在主板上，是硬件和软件的接口，为计算机最底层提供了控制服务。
- 启动bios后，会进行加电自检，检查硬件情况是否良好。
- 检测完毕后，就会显示引导程序，选择访问哪个外存来读取主引导记录。
- 根据启动顺序，读取主引导记录MBR，位于0柱面、0磁头、1扇区，共512字节。这个记录里包含了操作系统的位置、磁盘分区表等位置。
- 启动引导程序，加载操作系统内核文件，随后将控制权转交给操作系统。





# 进程

## 什么是处理机？

处理机就是计算机中存储程序和数据，并按照指令执行的部件。

通俗来说CPU的执行权，一个进程需要执行代码，就需要先获得处理机，才能够执行代码。

## 什么是进程？

 机，是系统进行资源分配和调度的一个单位，出现的原因就是让程序能够并发执行，采用一些调度算法将处理机合理地分配给进程。



## 进程是怎么创建的？

首先进行作业调度，当作业到达后，为其申请一个空白的PCB，里面填充上程序代码等程序的信息，然后为其分配其所需资源，初始化信息后，就进入进程调度，等待处理机的到来。



## 进程有哪些特性？

- 动态性：动态创建，动态执行，动态销毁。

- 并发性、独立性。

- 异步性：不同的进程按照各自独立的，不可预知的方向执行，但是执行的结果是可知的。



## 进程有哪些状态？？

- 创建、就绪、执行、阻塞、中止。



## 什么叫进程被挂起？

由于计算机的资源有限，如果进程一次性读入了大量的程序代码，但是执行的时候确是很晚，那中间这段时间的内存就被浪费了。为了解决这种现象提出了虚拟内存的概念，即每次只读入需要用到的资源，等到执行到内存没有的东西后，再去通过调页、换页的形式来请求资源。

挂起进程：就是将进程暂时调离内存，当条件允许后再重新调入内存。如果当前进程在执行将会被终止，如果在就绪态，则会保持就绪态不会被分配处理机。

## 那PCB是什么？

PCB就是进程控制块，描述了进程的基本信息和活动情况。系统通过PCB来了解这个进程的情况，从而进行控制和管理。

PCB的内容有：

- 进程标识符
- 外部标识符，便于其他进程访问。
- 内部标识符，便于OS访问。
- 进程的调度信息：如优先级、执行时间、等待时间、进程状态等。
- 处理机信息，通常就是处理机的上下文，这些上下文保存在很多寄存器中，表示当前处理机的状态，便于中断回恢复处理机现场。
- 进程的控制信息。如程序和数据的地址、通信机制、资源清单、连接指针（指向下一个pcb）



## PCB的组织方式有哪些？

- 线性方式，相当于数组，把所有PCB存放在一个区域，通过遍历来获取PCB。
- 链接方式，相当于链表，可以把相同状态的PCB放在一起，形成很多个队列，比如阻塞队列、就绪队列、执行队列。
- 索引方式，空间换时间，建立几张索引表，表项中存放PCB的地址，这些PCB在内存中是分散的。



## 进程的并发如何实现同步？

若要实现同步，就必须严格让进程按照顺序和一定的规则来访问资源，可以通过锁的机制实现。

硬件方面有：

- 关中断：在进入锁之前关闭中断，直到进程执行完临界区代码后，在打开中断。这样可以防止进程执行到一半响应中断，不会引发进程调度。
- test&set：是一条指令，在进入临界区之前先test一下，看看有没有锁，没有就上锁并访问，访问后再开锁。
- swap指令：全局有个锁，每个进程尝试用key去开锁，如果没有成功就一直尝试，直到开锁为止。

信号量：

- 整形信号量：定义资源的数量为S，通过PV原语操作来控制。P是请求资源，V是释放资源。
- 记录型信号量：用一个数组存放进程列表。在P操作中，先消耗资源S--，当S<0 时，说明当前的资源已经不足，不能满足进程，于是调用block原语将其阻塞并添加到列表中。在V操作中，先释放资源S++，当S<=0 时，说明有资源释放出来了，就调用wakeup原语唤醒列表中的某进程。





## :star:同步机制应该遵循的规则

空闲让进、忙则等待、有限等待、让权等待。





## 进程之间的通信有哪些？

管道通信：半双工通信，只能单向流动，处于父子进程之间。

信号：每个信号都有对应的操作，可以在任何时候发送给进程，无需直到进程的状态。

消息队列：将消息放入内存中的队列，有足够权限的进程可以进行推送或拉取。克服了信号承载信息量少的问题。

共享内存：由一个进程创建，其他进程可以访问。

信号量：用于通知进程某事件的发生。可以控制多个进程对共享资源的访问，常用于多线程。

socket：在进程之间建立起数据传输的通道。是IP地址和端口号的组合。是tcp对上层提供的接口，让操作系统发送各种tcp报文。



## :star:匿名管道和命名管道的区别？

**匿名管道**：只能单向通信，通常用于父子进程，依赖**字节流**进行通信。且匿名管道的生命周期随着进程的终止而结束。

	- node通信的步骤：调用pipe函数，父进程创建管道，得到两端的文件描述符。然后创建子进程并传给它两个文件描述符。最后父进程关闭读端，开启写端；子进程关闭写端，开启读端。

有几种情况：

1. 如果写端关闭了，此时读端读到没数据时会返回0；
2. 如果写端不写，则读端会读取剩余的数据，直到没有数据而阻塞在那里。
3. 如果读端关闭了，此时如果写东西就会抛出异常。
4. 如果读端不读，写端一直写数据，直到管道满了后，写端就会被阻塞。



**命名管道**：通过创建系统文件来进行通信，符合FIFO原则，因此任何两个不同的进程也可以通信。

跟匿名管道的区别就是**对于文件系统是可见的**，与路径名有关。

只要进程有权限访问该路径，就可以连接该管道。









# 线程

## 为什么要有线程？

由于进程的创建、切换和销毁的开销十分巨大，因此引入了较为轻量级的线程，作为资源调度和分派的基本单位。

## 线程的轻量级体现在哪？

创建：进程的创建需要创建PCB、分配资源、分配处理机、内存空间等。线程创建则不需要这些。

切换：进程切换需要保留CPU现场，然后将资源、处理机让出后，重新执行内存换页，然后进入进程调度，整个过程十分消耗。线程的切换只需要保留CPU现场，然后把现场还原给另一个线程即可。

销毁：进程销毁需要把上诉所有东西都销毁。



## 线程的状态有哪些？

- 就绪态、执行态、阻塞态。

## 线程实现同步的方法

- 临界区：在任意时刻只允许一个线程对共享资源的访问，是不可抢占的。
- 互斥量：mutex，拥有互斥对象的线程才能够拥有访问权。
- 信号量：允许在同一时刻有多个线程访问，但是有最大访问限制。







## 线程有哪两种？

管态：内核级别的，创建、切换、销毁都在内核中进行，可以很好的利用CPU，不需要进行线程调度。

用户态：在内核上的应用层面进行创建，内核无法感知用户态线程的存在。一个用户态线程阻塞将引起整个进程的阻塞。

- 比如说，一个进程的用户线程执行系统调用时，将导致这个进程中断；但是一个进程的内核线程阻塞仅仅是这个线程中断。







## :star:说一下进程和线程的区别

- 系统开销：进程创建时需要创建PCB，分配资源，销毁时需要回收内存，回收PCB空间，回收处理机，付出的开销比较大。进程切换时也是，需要回收内存、PCB、处理机，保留上下文；而线程由于共享同一个地址空间，切换只需要几个寄存器保存一下状态，然后恢复即可。总而言之进程的开销比线程要大的多。
- 调度方面：在传统的OS中，进程是资源分配和调度的基本单位， 每次被调度时需要进行上下文切换，开销较大；而引入了线程的OS将线程作为调度和分配的基本单位，线程切换时只需要保存少量信息到寄存器中，然后恢复给另一个线程，代价小。
- 并发性：进程可以并发，线程也可以并发。
- 资源拥有：进程拥有整个程序运行所需要的所有资源，线程不占有资源，只有一个创建时的TCB，但是线程之间是共享整个进程的资源的。
- 独立性：进程之间的独立性较强，拥有自己独占的地址空间和其他资源，不允许其他进程访问；而线程则共享同一个进程的所有资源和地址空间，每个线程都可以访问创建他们的进程的地址空间中的所有地址。



## 为什么虚拟地址切换会比较耗时？

因为页表是通过逻辑地址来转换物理地址的，这个转换的过程是非常慢的，所以需要一个cache来加速。

这个cache叫做TLB，用来记录已经转换过的地址。

一旦进程切换，页表就会被切换，进而这些TLB就失去了作用，而线程切换不需要切换页表，也就导致TLB还能发挥余光，所以线程的切换比较快。





## 线程的通信方式有哪些？

- 锁机制：如读写锁、互斥锁和条件变量等。
- 互斥锁就是防止数据结构被并发读取和修改。
- 读写锁允许线程同时读共享资源，但是只允许一个线程进行写。
- 条件变量一般配合互斥锁，用block原语阻塞线程，知道资源空闲后再释放线程。
- 信号量机制。





## 什么是协程？

协程就是轻量级线程，由开发者编写的代码，属于用户级别的线程， 对于操作系统内核来说不可见。

每个线程可以拥有多个协程。如果一个线程占据了长时间的IO操作，那么就会使得整个系统的吞吐量下降，其他线程干等着，造成资源浪费。

所以协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，类似于异步。

在React中，协程体现在Fiber的update优先级，通过优先级调度来让实现假异步，实际上就是高优先级的在当前时间片执行，低优先级的任务在下一个时间片执行。





## 协程的特点是什么？

1. 线程的切换由操作系统负责调度，协程的切换由用户自己调度，减少了上下文切换，提高了效率。
2. 线程默认的栈大小是1M，协程是1K，因此协程更加轻量。
3. 可以通过锁的机制来避免竞争关系。
4. 适用于被阻塞、高并发的场景。如果出现IO阻塞，先记录下当前线程栈上的数据，让协程去完成IO操作，等IO阻塞完后，通过线程恢复栈，把IO结果给线程去跑，这样看起来就像是同步代码在执行。



## 那线程和协程的区别有什么？

1. 线程占用资源大，执行栈为1MB；协程的执行栈为1KB左右。
2. 调度方面，线程由系统调度，协程由用户调度。
3. 切换开销，线程切换时涉及到用户态切换到内核态，大约需要16个寄存器进行保存；而协程只需要涉及到CPU上下文切换，只需要少量寄存器。而且线程的栈空间也比协程大。
4. 数据同步方面，线程需要通过锁的机制来确保数据一致性；协程由于共享线程数据，只需要判断状态来读写即可。







# 作业调度

## 处理机的调度分为哪些？

- 高级调度：就是长程调度和作业调度，根据调度算法从外存中的后备队列中取出作业，为其创建进程后，放入到就绪队列。
- 中级调度：内存调度，就是将哪些暂时不能运行的进程调到外存上等待。
- 低级调度：就是短程调度和进程调度，根据调度算法从就绪队列中取出进程，为其分配处理机并执行。



## 什么是周转时间、平均周转时间？

周转时间：指的是从提交作业到执行结束的这段时间，包括：

- 外存中的后备队列等待的时间
- 进程在就绪队列上等待的时间
- 进程的执行时间
- 进程被阻塞的时间

平均周转时间：n个进程的周转时间的平均值。



## 作业的数据结构是什么？

JCB：作业控制块，记录了作业的程序和数据，以及作业在内存中的标识，进行作业调度的所需信息等。

## 作业调度是在调度什么？

就是根据JCB的信息，看看系统能否满足这个作业的需求，如果合适就为其创建进程和分配资源。

## 作业的调度算法有哪些？

FIFO、SJF、优先级调度、高响应比优先（与等待时间和要求服务时间有关）







# 进程调度



## 进程调度分为哪两种方式？

- 非抢占式：一旦进程分配到处理机后，就不会因为时间片或者其他原因抢占掉这个处理机，直到进程销毁为止。
- 抢占式：允许调度的时候根据某些规则，将当前的处理机让出给其他进程。
- 抢占式原则有：优先权原则、短进程优先、时间片轮转。



## 轮转调度算法

所有进程排成一个就绪队列，每个进程都获得一定时间的处理机占有权，时间片结束后，就暂停当前进程，保留处理机信息，让出处理机给其他进程，调度至就绪队列队尾，等待下一个时间片的到来。

对于时间片，如果时间片过小会造成进程频繁切换，开销很大；如果时间片过大，又会导致某些进程等待很久，变成先来先服务了。





## 优先级优先

分为两种：抢占式和非抢占式。

确定优先级的因素有：是否是系统进程、进程对资源的需求小的优先、用户自定义。

优先级有两种：

- 静态优先级：预先确定好的优先级，一旦确定就不能改变，可能会造成低优先级饿死的现象。
- 动态优先级：根据周转时间计算出来的优先级，可以避免一些进程等待时间过长而饿死。



## 多级反馈队列调度算法

根据不同的进程类型分成多条队列，每个队列分配到的时间片不同，最前面的队列时间片最短，后面的队列依次乘2。

当一个进程进来时，首先进入第一梯队，如果在第一梯队的时间片内不能执行完，就进入第二梯队.

后面的队列能够执行的条件是，前面的队列为空闲。







# 死锁

## 资源的种类有哪些？

- 可抢占式资源：这种资源如果被进程抢占后，其他进程依然可以抢占这些资源，因此不会发生死锁。
- 非抢占式资源：这种资源如果被进程抢占后，直到进程主动释放前是不会被其他资源抢占的，因此构成了死锁的一个条件。
- 可消耗性资源：临时资源，由进程创建并销毁。
- 可重用性资源：可供用户重复使用的资源，进程无法销毁或创建更多此类资源，每个可重用资源是不可抢占的。

## 死锁的原因是什么？

- 多个进程对非抢占式资源的竞争。比如p1占有资源a，请求资源b。p2占有资源b，请求资源a。而双方保持着自己的资源不释放，而又一直等待对方释放资源，由此造成死锁。

- 进程推进顺序不当也会引起死锁。



## 死锁产生的必要条件是什么？

- 互斥条件：某资源只能由一个进程占有，其他进程请求必须等待。
- 不可抢占条件：一旦资源被占有，就必须等到进程释放后才能被其他资源占有。
- 请求和保持：在请求其他资源的时候，等待过程中不释放自己占有的资源。
- 循环等待：等待的进程中存在闭环。



## 如何预防死锁？

就是破坏四个条件之一即可。

## 如何避免死锁？

关键词：安全状态。

安全状态指的是如果将资源分配给该进程后，能够保证其他进程能够顺利推进，那么就可以分配该资源。

在分配资源时，可以利用银行家算法计算一下是否安全。



## 那银行家算法流程是什么？

有几个数据结构：可用资源向量Available，需求矩阵Need，已分配矩阵Allocate，请求矩阵Request。

算法流程：

- 如果request > need,说明已经超出了最大请求，不分配。
- 如果request > available，说明资源不足了，不分配。
- 然后假设分配给这个request，进入安全检测。
- 从其他进程中找出能够满足条件的，将其设置为finish，直到没有进程满足。
- 如果所有进程都能够finish，说明此次分配是安全的，安全通过。
- 如果有一个不是finished，说明不安全，不安全， 阻塞这个请求的进程。



## 如何检测是否死锁了？

可以用资源分配图。

- 资源指向进程，说明资源分配给了进程。
- 进程指向资源，说明进程请求资源。

如果图中存在环，那就说明死锁了。



## 如何解除死锁？

终止进程或者使用抢占式资源。





# 计算机硬件

## 什么是控制器？

设备和设备控制器连在一起，当设备io完成后，控制器通过产生中断指令来通知CPU操作已完成。

控制器中有寄存器、缓冲器，用来给设备和CPU传递数据。



## :star:如何确保一个进程能够访问合法的空间？

系统中有个界限寄存器和基址寄存器。

基址寄存器：存放进程的起始地址。

界限寄存器：表示进程的长度。

有了这两个寄存器，就可以确保进程在合法的空间内访问，如果发生了越界，则会产生越界中断及时止损。



## :star:什么是系统调用？

系统调用就是运行程序和操作系统的接口，程序通过系统调用来执行相关系统操作。

系统调用的过程：

1. 产生中断指令。
2. CPU执行到该指令时中断，发出相关信号给中断处理机构。
3. 中断处理机构保留CPU现场，即：用户栈指针、系统调用号、通用寄存器等。
4. 启动相关处理程序去完成该系统调用的需求。



## 程序和系统之间是如何传递参数的？

1. 寄存器传参。
2. 将参数保存在表中，寄存器记录地址。
3. 程序将参数压入栈，操作系统弹出。



## 什么是驱动？

驱动就是用来抹平不同系统对于设备的支持，一个设备可以有多种驱动程序，用来应对不同的系统。

设备驱动具有最高的权限，驻留在内存的底层处理程序。

驱动的处理过程：

1. 首先接收到调用请求，将其转化为具体需求，也就是初始化一些参数。
2. 检查用户IO的合法性，以及IO设备的状态，传递相关参数。
3. 发出IO命令，启动设备完成IO操作。
4. 如果有中断会及时处理中断，调用相关中断处理程序。



# 内存管理

## 程序进入内存的流程？

首先是获取到源程序，然后对源程序进行编译，到目标库或者内存中找到依赖，装入到模块中，再装入到程序，最后将程序装入到内存。

但是这有个问题，就是程序装入内存中，地址是不确定的，如果程序中的代码有访问某些绝对的物理地址就会报错，于是就有三种情况：

1. 在编译时期，如果确切直到物理地址，可以生产绝对代码。
2. 在装入时期，如果还不知道进程会在哪个地址，必须生成可重定向代码。
3. 在执行时期，如果进程在内存中是可以移动的，地址绑定一定得等待执行的时候进行，就需要逻辑地址和物理地址的映射。



## :star:什么是MMU？

memory management unit ， 内存管理单位，硬件将逻辑地址映射到物理地址，方法就是将基址寄存器的值加到用户进程产生的每个逻辑地址中，通过组装可以形成真正的物理地址。





## 是如何分区的？

固定内存分区，就是将内存分成固定大小的连续分区，一旦划分后，分区的大小和数量不会改变。但是这种会造成内碎片的问题，且分区数量确定还会限制进程的并发量。

动态内存分区，根据作业到来动态分配内存。需要借助分区表来记录进程的分配情况。

比如一个作业到来，OS会找到能够容纳下这个作业的分区并分配给他，这样就需要一些内存分配算法。



## 空间分配算法有哪些？

- 最先适应：分配首次适配的分区给作业。
- 最佳适应：遍历整个分区表，找到合适条件的最小的分区分配给作业。
- 最坏适应：遍历整个分区表，找到合适条件的最大的分区来分配作业。

最佳适应会造成大量小内存碎片，导致这些空间无法被利用起来。

最坏适应可以使得内存碎片尽可能少，但是如果有一个大的作业，可能会造成空间不足问题。



## 为什么一个进程在IO时不能去移动他？

因为进程处于IO时，意味着他被中断了，而中断处理机构会将当时的CPU现场保存在寄存器中，如果此时改变了进程的地址，那么等IO完成后，恢复CPU现场时就会找不到这个进程，导致GG。



## 为什么会有分页式管理？

首先，由于前面讲的都是连续空间，这样就会造成一些内存碎片的产生。

而分页式管理就是打破这种连续规则，即逻辑地址是连续的，但是物理地址是零散的。这样就可以将一个进程放在不连续的内存空间了。

有了页表，意味着要访问两次内存，第一次是找到进程对应的页，第二次是通过页找到真正的物理地址。



## 分页的具体过程是？

首先将物理地址分为大小相同的块，将逻辑地址分成数量相同的页。

每一页表项存放了逻辑地址对物理地址的映射。

页表的结构：存放物理地址的基址+偏移量。

查询时，先从进程的信息中查到所有页号，通过页号找到对应的页表项，然后从里面读出基址和偏移量，组装起来后就能找到对应的物理地址段了。

**所以，一个进程有很多页，可以通过每一页的页号去页表找到物理基址和偏移量，将两者组装起来，得到真正的物理地址。**



## TLB是什么？

联想寄存器，记录了最近读取过的页号，即查即用不需要访问内存。

这个出现的原因就是如果每个进程查询都需要访问两次内存，一次查页，一次通过页号访问物理地址，这样效率太低。

TLB相当于一个缓存，如果能够命中缓存，就直接可以从寄存器中拿出页号和偏移量，然后通过地址变换机构转化成物理地址即可。



## 地址转换的过程？

1. 首先将PCB的页表复制到页表寄存器。
2. 如果页表长度超过了【有效地址寄存器】的页号，那么就会发生越界中断。
3. 否则就将页号对应的物理地址存放到【物理地址寄存器】
4. 然后再从【有效地址寄存器】中读出offset，与【物理地址寄存器】的值计算后，找到对应的物理块。





# 虚拟内存

## 为什么要有虚拟内存？

早期内存空间小，如果跑一个进程要把整个放入到内存，那么放不了多少个，所以就需要虚拟内存。

虚拟内存允许进程只装入一部分，没有用到的部分暂存在外存，如果遇到了缺页中断，就通过页面置换算法将外存中的页换进内存即可。



## 请求分页的页表有什么指标？

- 页号
- 物理号
- 标志位P：表示当前页是否在内存中
- 修改位M：表示页是否被修改过。由于每一页在外存都有一份副本，如果修改过就要通过IO回写外村的页，保证数据一致性。
- 访问位A：表示当前页被访问的次数。
- 外村地址



## 页面置换算法有哪些？

- 先进先出
- 最佳置换算法：找到未来不会被访问的页进行调换，但是实现难度大，因为要预知未来。
- LRU：选择最长时间没有被使用的页。

缺页率不仅跟页面置换算法有关，而且跟页面推进顺序有关。



## 什么是颠簸抖动？

就是频繁地出现调页行为。

出现抖动，会导致CPU的利用率下降，OS就会以为进程不够而继续调进程，更多的进程会导致更多的抖动，导致死循环。

所以为了防止抖动，需要给进程足够的帧空间，或者采取合理的工作集。

工作集就是包含了进程的大部分页，如果工作集足够大，那么页的种类就足够多，这样就不需要频繁调页。

OS会分配比工作集还多的物理块，如果物理块不足，会选择暂停一个进程让出物理块。



# 文件系统

## 文件有多少种保存方式？

- 连续结构：将磁盘分配成连续大小相同的块，一个逻辑记录可以存放在若干块。

  逻辑地址转化：逻辑地址 / 块大小 = 块号 …… 偏移量

- 链式结构：同样是块，但是一个逻辑记录分配在不连续的块中。具体就是一个块不仅存放信息，还存放指向下一块的指针，因此只需要知道第一个块就可。

  逻辑地址转化：逻辑地址 / （块大小-指针空间） = 块号……偏移量

  NTFS：new tect file system，以簇为单位分配内存。一个簇由多个块组成。

- 索引结构：每个文件有个索引表，里面存放了所有块的块号。知道了块号就可以知道物理地址。

  多级索引：一个索引表可以存放多个二级索引表，然后二级索引表指向物理块。



