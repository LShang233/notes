常见面试题：https://www.cnblogs.com/gaoht/p/11310365.html

# webpack构建原理

1. 初始化参数
2. 将参数初始化为compiler对象，注册插件，插件会监听webpack构建生命周期的事件节点，开始run
3. 从入口（Entry）开始，递归解析依赖的所有Module（也就是import等关键字引入的文件）
4. 每找到一个模块，会根据配置的loader进行相应的转换处理
5. 递归完成后，会解析出当前模块依赖的模块，以入口为单位进行分组（Chunk）
6. 将所有的Chunk转换成bundle文件输出Output（Chunk：一个Entry以及其所有依赖Module合并）

# 什么是Loader

webpack只认识JS文件，其他文件类型需要根据Loader的配置进行转换

同时Loader也可以在构建过程中，对代码进行一些修改。例如压缩代码，删除log，语法转换等等

# 介绍几个常见的Loader

1. css-loader style-loader
   - css-loader负责解析css文件里面的css。确定css文件中的引入依赖Css中也可以使用@import。最后，这些信息会整合到一个数组中。这个数组。记录着你使用的css文件。每个文件对应使用一个子数组存放，然后子数组中就你的样式信息。
   - 但是这个数组HTML是无法解析的。需要使用style -loader把这些信息提取出来。重新再整合，最后通过js代码注入到HTML中。
2. url-loader和file-loader
   - 通过outputPath属性控制图片的输出目录，name控制输出的名称，通过pulicPath确定引用到的正确资源路径
3. babel-loader。对js进行转码，兼容低版本的浏览器

# 插件

## 插件的原理

插件的本质是一个事件的订阅和发布。对应Tap和call。

webpack的compiler，compilation中存放着十分多的生命钩子。这些钩子是tapable库编写的。

webpack在初始化后封装的compiler对象里面，拥有着这些生命钩子，用户根据自己的需求在这些生命钩子函数中去tab。也就是订阅。当webpack执行到生命周期的时候，就会去call这些订阅的函数，从而实现插件的执行。

# 热更新

热更新的目的是为了加快用户的开发速度。

他允许在运行时替换，添加，删除各种模块。而无需进行完全刷新，重新加载整个页面。

1. 保留在完全重新加载页面时丢失的应用程序状态
2. 只更新改变的内容。以节省开发时间。
3. 调整样式更加快速。速度等同于在浏览器调试器中更改样式。

## 原理

webpack里的complier对象有一个watch方法，可以监听到webpack构建文件的修改

修改之后重新构建。重新构建的文件并没有直接写在磁盘中。而是存储到的**内存**系统中。

构建成功之后，通过订阅事件的形式，也就是插件中的done钩子，他会在构建结束之后进行广播。我们在这个钩子中通过web socket的send，通知客户端接受消息，重新检查更新。

Web socket是通过插件在入口的时候注入的。

# loader和plugins区别

loader（配置）主要用来处理文件。其原理是，把文件的字符串传入在输出一个已经处理好的字符串。

插件则用于事件订阅。在webpack整个生命周期中。有许多插件可以给用户去订阅。所以插件的功能比loader的丰富很多。插件是用来扩展webpack的功能，如压缩文件等。

# tree-charking原理

将一些无用的代码（死码）去除。

他利用了ESmodule的静态模块结构。

ES6module的特点是只能作为模块顶层的语句出现。这也就意味着依赖关系是确定的，和运行时的状态无关。所以可以进行可靠的静态分析，然后进行消除。

当chunk打包成bundle的时候使用tree-sharking

**实现方法：**

- 通过webpack进行标记。将import和export分为三类，其中export分为内使用过和未使用过
- 根据标记使用工具将代码精简，剔除未使用的代码

# commonJS和ES6Module的区别

commonJS是动态载入的，也就是说，只有在运行的时候，才能确定所依赖的模块是哪些。

他对于基本数据类型是**复制**，对于引用类型是浅拷贝。也就是说他可以通过改变引用的值。从而改变文件里面的内容。

ES6Module则是静态模块结构。不需要运行，就能确定所依赖的模块。

采用**动态只读**引用的方式加载模块代码。只读意味着无法去修改模块里面的内容。引用则表示当脚本真正执行的时候，才会去模块里面取值，并且这个取值的过程是异步的。

默认开启严格模式