采用异步的方式可以将时间消耗减到`max（M， N)` 

现在主流的方式有两种：

- 单线程串行依次执行
- 多线程并行完成

node采用了两者间的方案：

- 利用单线程，远离多线程死锁、状态同步等问题
- 利用异步I/O，让单线程远离阻塞，以更好地使用CPU

# 异步I/O与非阻塞I/O

[参考链接]: https://zhuanlan.zhihu.com/p/37640811

**1. 阻塞**

A调用B后，一直等着B返回结果。

这是最广泛使用，也是最简单的一种模型。普通的函数调用、传统的阻塞IO都是如此。

**非阻塞**：立即返回当前调用状态。为了获取状态，需要不断**轮询**

**2. 轮询**

A调用B后，A不断去B那里查询返回结果。

这在耗时任务中经常出现。比如一种资源的创建非常耗时，服务A通知服务B创建，B返回给A一个任务id或者资源id，A不断轮询B检查任务是否完成以及完成结果。这种也非常常见。在架构设计中，为了减少服务之间的循环依赖，常常不会让B再回去调用A。这样一来，在一个基于http的体系中，轮询是唯一解法。

**3. 阻塞回调**

A调用B后，A什么都不做，直到B通知A已完成

这种模式并不是经常出现，而且它实际上是异步回调的一个子集。在（资源非常少，无法承接多个任务 | 或者A通知B进行的是其他任务的前提）时，可能会选择这种模型。

**4. 异步回调**

A调用B后，该干啥干啥，B通知A已完成后，再继续处理该任务的后续任务。



**实现异步I/O**

glibc的AIO采用线程池模拟异步I/O，有难以忍受的缺陷和bug，不推荐采用

libeio：异步I/O的库。实际上依然是线程池与阻塞I/O模拟异步I/O

Windows下的IOCP。依旧是线程池原理，但线程池是由系统内核接手管理的



# node的异步I/O

## 1、事件循环

在进程启动是，会创建一个类似于`while(true)`的循环，一次循环称之为`Tick`

每个`Tick`的过程就是查看是否有事件待处理，有就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行。然后进入下一个循环，如果没有时间处理，就退出循环。

![image-20210719154706299](C:\Users\lshan\AppData\Roaming\Typora\typora-user-images\image-20210719154706299.png)

## 2、观察者

每个`Tick`的过程中，每个事件循环中有一个或多个的观察者，判断是否有事件要处理

观察者将事件进行分类



## 3、请求对象

js发起调用到内核执行完I/O操作的过渡过程中，有一个中间产物交请求对象

 js层面的代码通过c++核心模块进行下层操作，在调用过程中，创建了请求对象。

从js层传入的参数和当前方法都被封装在这个请求对象中，其中回调函数则被设置在这个对象的`oncomplete_sym`属性上。

对象包装完毕后，在Windows下，调用`QueueUserWorkItem()`方法将这个对象推入线程池中等待。

`QueueUserWorkItem()`有三个参数：

1. 将要执行的方法的引用
2. 将要执行的方法的参数
3. 执行的标志

当线程池有可用线程时，调用将要执行的方法，然后根据传入的参数的类型调用相应的底层函数。

至此，js调用立即返回，js可以执行当前任务的后续操作。

所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调函数



## 4、执行回调

`3、`完成后，完成了异步I/O的第一部分，第二部分是回调通知

线程池中I/O操作调用完毕之后，会将获取的结果存储在req->result属性上，然后调用`PostQueuedCompletionStatus()`方法通知IOCP，告诉当前对象操作已完成

该方法向IOCP提交执行状态，并将线程归还线程池。通过该方法提交的任务，可以通过`GetQueuedCompletionStatus()`提取

在每次`Tick`的执行中，会调用请求对象的`GetQueuedCompletionStatus()`检查线程池中是否有执行完的请求，如果有，则将请求对象加入I/O观察者的队列中，然后将其当做时事件处理

I/O观察者回调函数的行为就是去除请求对象的result属性作为参数，取出`oncomplete_sym`属性作为方法，然后调用执行，以此达到js传入的回调函数的目的

![image-20210719173005668](C:\Users\lshan\AppData\Roaming\Typora\typora-user-images\image-20210719173005668.png)

Windows主要通过IOCP向系统内核发送I/O调用和从黑河获取已完成的I/O操作，配以事件循环，以此完成异步I/O

Linux通过epoll

FreeBSD通过kqueue

Solaris通过Event ports

*nix系列通过libuv



# 非I/O的异步API

`setTimeout()`、`setInterval()`、 `setImmediate()`和`process.nextTick()`

## 1、定时器

`setTimeout()`、`setInterval()`

定时器并非精准的。

![image-20210719213559830](C:\Users\lshan\AppData\Roaming\Typora\typora-user-images\image-20210719213559830.png)

## 2、`process.nextTick()`

每次调用只会将回调函数放入队列中，在下一轮`Tick`时取出执行。

更高效



## 3、`setImmediate()`

与`2、`十分类似，都是回调函数延迟执行

该函数的回调函数执行的优先级低于前者

`process.nextTick()`属于`idle`观察者，回调函数保存在数组中，每轮循环执行数组的全部函数

`setImmediate()`属于`check`观察者，回调函数保存在链表中，每轮循环执行链表的一个函数

`idle`先于`I/O`先于`check`



# 事件驱动与高性能服务器

![image-20210720102353597](C:\Users\lshan\AppData\Roaming\Typora\typora-user-images\image-20210720102353597.png)

几种典型的服务器模型：

1. 同步式：一次只能处理一个请求，其余请求处于等待状态
2. 每进程/每请求：为每一个请求启动一个进程，这样可以处理多个请求，但是他不具备扩展性，因为系统资源固定
3. 每线程/每请求：为每个请求启动一个线程来处理。尽管线程比进程轻量，但由于每个线程都占用一定内存每当大并发请求到来是，内存很快会被用逛，导致服务器缓慢

虽然3比2的扩展性要好，但对于大型站点而言依旧不够，