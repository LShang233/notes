https://zhuanlan.zhihu.com/p/266578819

## HTTP/2.0 和 HTTP/1.1 的比较

### 1. 多个请求共享同一个 TCP 连接

- HTTP/1.1 多个请求共享一个 TCP 连接时，是**串行**共享，即前面请求没结束，后面的不会开始
- HTTP2 是采用**并行**策略，实现多路复用，而且不同的 HTTP 请求会有优先级别

### 2. 数据流格式

- HTTP/1.1 的数据流是**文本流**
- HTTP/2.0 采用**二进制分帧**形式，消息有一个帧或多个帧组成，服务器解析起来更快速

### 3. 是否支持服务器主动推送

- HTTP/1.1 不支持
- HTTP/2.0 支持

### 4. 首部压缩

- HTTP/1.1 的首部带有大量信息，而且每次都要重复发送
- HTTP/2.0 在客户端和服务器之间维护一个包含之前见过的首部字段表，每次请求只会发送更新的首部字段，另外还使用 Huffman 编码对首部字段进行压缩



## http1.0和1.1区别

1. 长连接：在http1.0中，TCP在每次的请求和响应之后就会进行关闭，TCP的连接和释放会是网络通信边得更慢，1.1优化了这个东西，默认开启connection：keep-alive，一次请求响应结束之后，不会马上断开TCP连接，而是保持这个连接。
2. 管线化技术，管线化技术是允许客户端在收到每个回应之前发送多个请求，进一步减少用户感受到的滞后时间



## http1.1和2.0区别

1. 多路复用技术：在持久化连接的基础上，允许所有的请求公用同一连接，并且能够**并行**传输。和管线化技术对比，管线化技术请求都是顺次发送出去的。多路复用中，请求是并行发送的。

2. 报文头压缩：减少http报文中头部字段的开销，提供通信的效率。我知道有点优化：第一点：对于单个HTTP报文而言，当携带较少的通信数据时，报文头部远大于数据，导致。第二点：持久化连接下，传送多个HTTP报文之间，经常存在重复的报文头字段。

   优化方法：静态字典压缩方法，客户端和服务端中维护一个字段，这个字典存放着意西常用的头部和对应的索引号，那么在传输的时候，我们使用索引号来代替完成的字符串传输。

   动态字典压缩：假如出现了一些头部在静态字典中不存在，那么我们首次传输的时候不要压缩，完成的传输，传输后加入到字典中，那么下次又可以使用索引号进行传输

3. 服务端推送：http2打破了严格意义上请求-响应，支持服务器发起的推送工作流。服务器可以对客户端发送器的请求有相应外，还可以向客户端推送给额外的资源，需要客户端再次请求



# 多路复用（链接共享）— 真并行传输

- **流（stream）**：已建立连接上的双向字节流。
- **消息**：与逻辑消息对应的完整的一系列数据帧。
- **帧（frame）**：HTTP2.0通信的最小单位，每个帧包含头部，至少也会标识出当前所属的流（stream_id）

所有HTTP2.0通信都在一个TCP链接上完成，这个链接可以承载任意流量的双向数据流。

每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据**每个帧头部的流标识符**（Stream_id）重新封装。

多路复用（连接共享）可能会导致关键字被阻塞，HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回客户端，数据流还可以依赖其他的子数据流。

可见，HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量的HTTP请求。而这个强大的功能基于“二级制分帧”的特性。



局限：在出现丢包的额情况下，整个TCP都要开始等待重传，导致后面的所有数据都被阻塞。



# HTTP3.0

主要是基于UDP协议的QUIC协议

## 优势

缓存当前会话的上下文，下次恢复会话的时候，只需要将之前的缓存传递给服务器，验证通过，就可以进行传输了。

**0-RTT**建连可以说是QUIC相比HTTP2最大的性能优势。

在0-RTT的时间建立连接或加密连接

## 特点

- 连接时：通过ID识别，只要ID不变即可连接
- 丢包时：只需要重传丢失的包，不需要重传链接
- 加密：连报文头部都有加密（除了个别报文）
- 向前纠错：除了自己数据包的信息还会有其他数据包的信息，这样当丢包的时候，可以根据其他的包计算出丢失包的数据

# 总结

## HTTP 1.0

- 无状态，无连接
- 短连接：每次发送请求都要重新建立tcp请求，即三次握手，非常浪费性能
- 无host头域，也就是http请求头里的host，
- 不允许断点续传，而且不能只传输对象的一部分，要求传输整个对象



## HTTP 1.1

- 长连接，流水线，使用connection:keep-alive使用长连接
- 请求管道化
- 增加缓存处理（新的字段如cache-control）
- 增加Host字段，支持断点传输等
- 由于长连接会给服务器造成压力



## **HTTP 2.0**

- 二进制分帧
- 头部压缩，双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小
- 多路复用（或连接共享），使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求
- 服务器推送（Sever push）



## HTTP 3.0

- 基于google的QUIC协议，而quic协议是使用udp实现的
- 减少了tcp三次握手时间，以及tls握手时间
- 解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题
- 优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗
- 连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接
- 更合适的流量控制

> 基于UDP实现
> 0RTT建连
> 基于UDP的多路复用
> 加密认证的报文
> 向前纠错机制

# HTTPS

## 一、HTTP 的缺点

1. 通信使用明文 → 内容可能被窃听
2. 不验证通信方的身份 → 第三方可以伪装成通信方
3. 不验证报文的完整性 → 报文可能被篡改

针对这些缺点，提出了 HTTPS → **HTTP + 加密 + 认证 + 完整性保护 = HTTPS**

## 二、HTTPS

### 2.1 概述

HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443

HTTPS 本质是身披 SSL 外壳的 HTTP。在采用 SSL 后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。

### 2.2 加密

#### 1. 共享密钥加密（对称密钥加密）

通信双方持有一样的密钥，对通信内容进行加密和解密。

它的困境在于，在通信开始前，**拥有密钥的一方如何将密钥安全地转交给通信的另一方**。

#### 2. 公开密钥加密（非对称密钥加密）

公开密钥加密方式，采用两把密钥：公钥和私钥。**公钥可以随意发布，私钥只有自己拥有**。

在通信开始前，服务端将公钥发给客户端，然后客户端用公钥对通信内容进行加密，服务端收到加密内容后用私钥对其进行解密。

因为公钥可以随意发布，所以它解决了对称加密的困境。

但是，它也有自己的困境：**客户端无法判断收到的公钥的正确性**。



#### 4. HTTPS 的加密方式

HTTPS 采用对称密钥加密和公开密钥加密混合的加密机制。

1. 先使用公开密钥加密进行通信，客户端向服务端传递一把共享密钥。
2. 后续的通信，用刚刚传递的共享密钥来进行对称密钥加密通信。

### 2.3 认证

#### 3. 认证服务端

刚刚说过，公开密钥加密的缺点在于，无法判断服务端发送过来的公钥正确性，或者说是无法判断服务端的正确性。

为了证明客户端收到的公钥的正确性，可以委托权威第三方机构来进行认证。

服务端生成公钥密钥后，会让第三方机构给自己的公钥颁发证书。然后在发送公钥到客户端时，把证书也连同发送过去。

客户端收到公钥和其证书后，对证书进行验证，验证通过，则相信该公钥的正确性，也就相信了服务端的正确性。

> 第三方机构颁发公钥证书时，会用本机构的私钥对证书上的数字签名进行加密。
>
> 而客户端，比如浏览器，会自带常用第三方认证机构的公钥，**这个公钥可以判断一份公钥证书的数字签名是否是用对应私钥加密的**，因此可以判断证书是否是其颁布的，进而判断了证书的合法性公钥的正确性。
>
> 所以，客户端真正信任的不是拥有公钥的服务端，而是给公钥颁布证书的第三方机构，因为信任第三方机构，所以才相信服务端。

#### 4. 认证客户端

客户端也有客户端证书，作用跟服务端公钥证书如出一辙。

不过它存在两个问题：

1. 获取困难。客户端证书一般需要用户自行购买和安装。
2. 认证缺陷。客户端认证的不是客户本身，而是安装了证书的计算机。

### 2.4 完整性保护

应用层使用 HTTPS 时，发送数据时会附加一种叫 MAC 的报文摘要。MAC 能够判断一份报文是否遭到篡改，从而保证报文完整性。

HTTP 其实也有报文摘要机制 MD5，但是因为 HTTP 是明文传输，篡改报文摘要也不是难事。

但 HTTPS 有加密和认证机制，想要成功的篡改一份已经加密过的报文摘要是很困难的。

### 2.5 HTTPS 的缺点

1. 与 HTTP 相比，HTTPS 的通信速度更慢。（一是因为通信过程变复杂，二是因为消耗更多的资源）
2. 需要支付证书认证等高额费用。

### 2.6 建立 SSL 通信的四次握手

![](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20220223154035.jfif)

1. 第一次握手，客户端发起 SSL 通信请求。
2. 第二次握手，若服务端同意连接，则发送公钥和公钥证书给客户端。
3. 第三次握手，客户端认证公钥证书后，生成随机密码串（共享密钥），并用公钥加密后发送给服务端。
4. 第四次握手，服务端收到报文用密钥解密，得到随机密码串（共享密钥）。

第四次握手后，双方都拿到了共享密钥，后序的通信就用共享密钥进行通信。

TLS协议：三次握手+SSL通信+两次确认

