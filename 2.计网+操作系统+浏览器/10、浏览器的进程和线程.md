# 进程和线程

进程时CPU**资源分配**的最小单位

线程是CPU**调度**的最小单位



# 浏览器是多进程的

从任务管理器可以看到，每打开一个页面，就相当于创建了一个独立的浏览器进程。

所以说浏览器是多进程的。

## 浏览器都包含哪些进程

1. 主进程（负责协调、主控）只有一个
   - 界面显示、与用户交互。如前进，后退。
   - 创建和销毁其他进程。进行页面管理。
   - 网络资源管理、下载等
2. 第三方插件进程
3. GPU进程，最多一个，用于3D绘制。
4. 浏览器渲染进程（浏览器内核）：每个页面一个进程互不影响。主要用于页面渲染，脚本执行、事件处理的。

## 浏览器多进程的优势

- 避免单个影响整个浏览器。
- 避免第三方插件影响整个浏览器。
- 多进程利用多核的优势。
- 方便使用沙盒模型隔离插件等进程，提高浏览器的稳定性。

## 浏览器内核（渲染进程

页面的渲染，js的执行，事件的循环都在这个内核进行。

1. Gui渲染线程。
   - 解析HTML，css构建DOM数和RenderObject数布局和绘制等。
   - 进行重绘和回流。
   - 与js引擎线程互斥。
2. Js引擎线程（主线程
   - 负责处理JavaScript脚本程序。（V8
   - 一个页面只有一个js线程。
3. 事件触发线程（任务队列
   - 用来控制事件循环。可以理解为协助js引擎的线程。
   - Settimeout，异步请求等都会加入到这里。
4. 定时触发器线程
   - SetTimeout, setInterval在的线程。
   - 计时完毕后，添加到事件队列。
5. 异步HTTP请求线程
   - XMLHttpRequest请求就是通过浏览器开一个线程请求
   - 状态跟变时，如果有回调函数，异步，线程就产生状态更变事件。把这个回调放入事件队列中。

## 主进程和渲染进程的通信过程

- 主进城收到用户请求。首先获取页面内容下载资源。然后该任务通过rendererhost接口传递给rander进程。
- 渲染进城街道小溪后，简单解释以后，交给渲染线程开始渲染。
  - 渲染线程接收请求加载页面并渲染页面。其中可能需要主进程获取资源和GPU进程来帮助渲染。
  - 还可能会有js线程操作的。这样可能会导致回流并重绘
  - 最后渲染进程，将结果传递给主进程。
- 主进程接收到结果，并将结果绘制出来。

# 浏览器内核中线程之间的关系

## Gui渲染线程与js引擎线程互斥

因为js是可操作dom的。如果在修改这些元素属性同时渲染界面可能会导致渲染前后元素的数据不一致。

## Js阻塞页面加载

因为互斥，所以js执行时间过长，就会阻塞页面。

## web worker

创建worker时：Js引擎向浏览器申请开一个子线程。

二者通过特定的方式通信。postMessage API

## webworker和sharedworker

webworker只属于某个页面。

sharedworker浏览器的所有页面共享。与webworker线程不是同一个，浏览器会给他单独创建一个进程来运行。每个相同的js只会存在一个worker进程，不管他被创建多少次。

所以他们本质上就是进程和县城的区别。

# 简单梳理一下浏览器渲染流程

浏览器内核拿到内容之后，

1. 解析HTML建立dom数。
2. 解析css构建render数（与js树合并
3. 布局Render数，负责个元素。尺寸，位置的计算。也就是回流。
4. 绘制render树绘制页面像素等信息。也就是重绘。
5. 将各程信息发送给GPU。GPU将各程合成显示在屏幕上。

![image-20220217171457045](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20220217171631.png)

## load事件与DOMContentLoaded事件的先后

DOMContentLoaded：DOM加载完成

load：DOM、样式、脚本、图片都加在完成

