参考：计算机网络 第七版（谢希仁著）

前端主要掌握网络层以上的内容，所以本文基本不涉及物理层和数据链路层

主要是为了应付面试，所以也不涉及更详细的 如IP数据报的格式、路由转发方式等内容

![image-20211119164352211](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211119164359.png)

# 网络层

网络层为主机之间提供逻辑通信

## IPv4

与IP协议配套使用的还有三个协议

- 地址解析协议ARP
  - 已知机器的IP地址，求其硬件地址
  - 所以ARP是衡阔数据链路层和网络层的协议
- 网络控制报文协议ICMP
  - 目的：更有效的转发IP数据报和提高交付成功的机会
  - 允许主机或路由器报告差错情况和提供有关异常情况的报告
  - ICMP报文长在IP数据报中，所以是IP层的协议
- 网络组管理协议IGMP

将网络互连的中间设备：

- 物理层：转发器
- 数据链路层：网桥或桥接器
- 网络层：路由器（其实是一台专用计算机）
- 网络层以上：网关



### IP地址及其表示方式

经历了三个历史阶段：

#### 1、分类的IP地址

我们知道IP地址是一个32位的二进制码，最开始将其记为`IP地址 ::= {<网络号>,<主机号>}`

并将其分为五类

![image-20211119165518591](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211119165518.png)

除去一些一般不使用的特殊IP地址，就是网络上的所有IP了

![image-20211119165853121](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211119165853.png)


#### 2、子网的划分

随着计算机的普及，需求变化，仅仅三类的IP地址显得不够灵活

`IP地址 ::= {<网络号>,<子网号>,<主机号>}`

数据会先传进大网络的路由，再转发到所属的子网

（如IP地址145.13.3.10先到145.13.0.0，再由他转发到子网145.13.3.0）



假设数据到了145.13.0.0，我要怎么找到子网145.13.3.0呢

因为IP地址和数据报本身是不含子网划分的信息的，所以我们需要子网掩码

（子网划分并没有改变IP数据报的格式，只是在所有主机增加了子网掩码的字段）

当IP地址145.13.3.10的数据报到达145.13.0.0的网络时，会与当前网络的子网掩码进行与操作，若与当前的网络号一致，即表示到达目的网络

![image-20211119171729621](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211119171729.png)

划分子网虽然增加了灵活性（也因为这个提高了利用率），但却减少了能够连接在网络上的主机总数



#### 3、构成超网

由于用户数的递增，IPv4的地址空间耗尽

出现了无分类域间路由器CIDR：

`IP地址 ::= {<网络前缀>,<主机号>}`

消除了ABC类和划分子网的概念，采用斜线表示网络前缀所占的位数

![image-20211119173303541](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211119173303.png)

其中`/20`就是指地址掩码中，1的个数



## IPv6

主要变化：

- 地址空间：从32位增加到128位
- 看图吧……

![image-20211119204452347](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211119204452.png)

ipv4 和ipv6 的区别本质在于它们的二进制表示位数：

- ipv4是用32位0/1序列来表示的
- 而ipv6使用128位0/1序列来表示的

ipv4用32位，为了方便人类记录和阅读，我们通常将ipv4的32位0/1分成4段8位序列，并用10进制来表示每一段(这样，一段的范围就是0到255)，段与段之间以“.”分隔。

而ipv6的话是用十六进制来表示的，同样是为了方便人类记录和阅读。它也按照8位分割，以16进制来记录每一段(使用16进制而不是10进制，这能让写出来的IPv6地址短一些)，段与段之间以“：”分隔。

> 原文链接：https://blog.csdn.net/zt13258579889/article/details/78885196



## ICMPv6

![image-20211119205732334](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211119205732.png)

IPv6和IPv4一样，不能保证数据报的可靠交付

所以也需要ICMP来反馈差错信息

ICMPv6将ARP和IGMP的功能合并



## IPv4过渡到IPv6

因为规模太大，只能逐步演进

使用两种协议：

### 1、双协议栈

使一部分主机或路由器装有双协议栈，即既能使用IPv4又能使用IPv6

如何判断是目的主机使用的是哪种地址呢？答案是用DNS来查询。

如果两个装有双协议栈的主机中间，要经过一个未装有双协议栈的主机，IPv6首部的某些字段是无法恢复的

### 2、隧道技术

将IPv6数据报变成IPv4数据报的数据部分

就是将整个IPv6数据报加上IPv4的头，这个头的协议字段设为41（表示我的数据是IPv6的数据）



# 运输层

运输层向它上面的应用层提供通信服务，提供应用进程间的逻辑通信

![image-20211120104917973](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211120104918.png)

我们知道，IP层能找到对应主机，但如何找到对应的应用进程呢

我们需要使用端口号

- 服务器端使用的端口号：
  - 熟知端口号，又称系统端口号（0~1023），给最重要的应用程序
    - ![](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211120105631.png)
  - 登记端口号（1024~49151），没有熟知端口号可使用时，在IANA登记后使用
- 客户端使用的端口号（49152~65535）
  - 又称短暂端口号，因为这类端口号仅在客户进程运行时才动态选择
  - 通信结束后，刚才使用过的客户端口号就不复存在了



## UDP

用户数据报协议UDP

数据单元：UDP用户数据报

### 主要特点：

- 无连接。发送前不需要建立连接
- 尽最大努力交付。不保证可靠交付，所以主机不需要维持连接状态表
- 面向报文。即保留报文边界，如图：
  - ![image-20211120110715401](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211120110715.png)
- 没有拥塞控制。
- 支持一对一，一对多，多对一和多对多的交互通信。
- 首部开销小。8个字节，TCP是20个字节
  - ![image-20211120110957547](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211120110957.png)



## TCP

传输控制协议TCP

数据单元：TCP报文段

### 主要特点：

- 面向连接的运输层协议。
- 每一条连接只能有两个端点。即点对点、一对一
- 可靠交付。底层并不是可靠的，是通过一些手段，如让丢失的数据重发等，使TCP无差错、不丢失、不重复，并按序到达
- 全双工通信。双方任何时候都能发送数据。
- 面向字节流。虽然应用和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流，如图：
  - ![image-20211120112014640](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211120112014.png)



**TCP的连接：**

TCP把链接作为最基本的抽象

`TCP链接 ::= {socket1, socket2} = {(IP1 : port1), (IP2 : port2)}`



### 可靠传输的工作原理

可靠传输：无差错、不丢失、不重复，并按序到达



#### 停止等待协议

全双工通信的意思是双方既是发送方也是接收方，以下是A作为发送方，B作为接收方的情况下讨论的



##### 1、无差错情况

如图(a)所示，当确认对方收到信息后再发送下一条信息

![image-20211121211524319](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121211531.png)



##### 2、出现差错

如上图（b）所示，若在一定时间内未收到B发来的确认信息，则表示出现了差错，则进行超时重传

为实现这个操作，需要注意以下三点：

1. 必须暂时半流已发送的分组的副本
2. 要对每一个分组进行编号
3. 超时计时器要比数据在分组传输的平均往返时间更长一点，具体要根据网络的拥塞情况等因素决定



##### 3、确认丢失和确认迟到

若A进行重传后，B收到了之前丢失的分组（收到了两个同样的信息）

此时会采取两个行动：

1. 丢弃重复的分组
2. 向A发送确认（重复信息也要发送），A收到确认，发现是重复的后，会直接丢弃迟到的确认

这种可靠传输协议通常称为**自动重传请求ARQ**，即重传的请求是自动进行的



##### 4、信道利用率

停止等待协议简单，但是信道利用率很低

![image-20211121213836525](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121213836.png)

为改善这种情况，采用流水线传输

![image-20211121213909448](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121213909.png)

而使用流水线传输，需要使用连续ARQ协议和滑动窗口协议



#### 连续ARQ协议

![image-20211121214057612](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121214057.png)

一般采用累积确认的方式，对按序到达的最后一个分组发送确认，这就表示，这个分组前的所有分组都到了

- 优点：容易实现，即使确认丢失也不必重传
- 缺点：不能向发送方反应接收方已经收到的所有分组信息（按序到达的最后一个分组  往后的分组）



#### 滑动窗口协议

TCP滑动窗口是以字节为单位的

![image-20211121215014770](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121215022.png)

发送窗口前沿也可能向后收缩（对方通知的窗口缩小时），但TCP标准强烈不赞成这样，因为很可能发送方在收到这个通知的以前已经发送了窗口中的许多数据，收缩窗口后则不允许发送这些数据，会产生错误

![image-20211121220227534](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121220227.png)

![image-20211121220321294](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121220321.png)

这种情况下，A无法行动，在经过一定时间后会进行超时重传

![image-20211121220550663](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121220550.png)

**缓存与窗口的关系**

![image-20211121220704067](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121220704.png)

如图（a）所示，发送缓存用来暂存：

1. 发送应用程序传达给发送方TCP准备发送的数据
2. TCP已发送出但暂未收到确认的数据

如图（b）所示，接收缓存用来暂存：

1. 按序到达、但尚未被接收应用程序读取的数据
2. 未按序到达的数据



### TCP流量控制

意思是让发送方的发送速率不要太快，要让接收方来得及接收

（这些字母是TCP的一个头部信息，可以自行了解...）

![image-20211121221921875](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121221921.png)

注意，最后一步之后，若B又有了空间，向A发送了开启窗口的报文，结果这个报文丢失了

那么会陷入死锁，都在等待对方的消息

所以，TCP为每一个连接设有一个持续计时器，只要一方收到零窗口的通知，就会开始计时，计时结束发送一个探测报文段（1字节数据），对方在收到这个报文时返回当前的窗口值



### TCP拥塞控制

![image-20211121223646645](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121223646.png)

**拥塞控制的方法：**

1. 慢开始
2. 拥塞避免①③
3. 快重传④
4. 快恢复⑤

**慢开始、拥塞避免和快恢复：**

![image-20211121223854672](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121223854.png)

**快重传：**

可以尽早知道发生了个别报文的发送丢失

只要一连收到3个重复确认，就立即进行重传

![image-20211121224055340](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121224055.png)

可以根据流程图帮助理解：

![image-20211121224505593](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121224505.png)



### TCP的运输链接管理

一共分为三个阶段：链接建立，数据传送，链接释放



#### 连接建立（三次握手）

C端:客户端; S服务端

第一次握手: C端向S端发送SYN数据包〈SYN=1，序列号=x)。A迸入SYN_ SENT状志，等待服务端确认。

第二次握手: S端收到SYN数据包并进行确认(SYN=1, ACK number=x+1, ACK=1,序列号=y)，再发送SYN+ACK数据包给C端，S端迸入SYN_ RCVD状志。

第三次握手: C端收到SYN+ACK数据包，如果ACK number=x+1,将ACK number设置为y+1, ACK=1，向S端发送ACK数据包，C端和S端都进入ESTABLISHED (已连接)状志。

> 原文链接：https://blog.csdn.net/qq_38542085/article/details/91820528

**可以简单理解为：**

A：我要连你了

B：好啊好啊

A：我已经连你了哈（开启链接）

B收到后（开启链接）

![image-20211121224609959](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121224610.png)

**为什么要三次握手?**

1. 为了防止已失效的连接请求报文段突然又传到了服务端，产生错误。
2. 同时保证发送双方的消息发送与接收功能都可用。

**解释:**报文段已发送，在某个网络节点发生滞留，导致连接释放,释放后报文才到达另一端。

**例如:** C端发送SYN报文给S端，连接被释放后，S端才收到报文并误认为这是C端的新连接，给C端发送SYN+ACK报文，这是无法得到C端回应的，因为连接已无效。



#### 链接释放（四次挥手）

第一次挥手: A给B发送FIN报文(序列号=x)，A进入FIN_WAIT_1状态，表示A没有数据给B了。

第二次挥手: B收到FIN报文后，给A发送ACK报文(ACK=x+1)，A进入FIN_WAIT_2状态,B同意A关闭请求。

第三次挥手: B向A发送FIN报文(序列号=y)，请求关闭连接，B进入LAST_ACK状态。

第四次挥手: A收到FIN报文,向B发送ACK报文(ACK=y+1) , A进入TIME_WAIT状态，B收到ACK报文后关闭连接，A在2MSL后依然没收到回复，证明B端己关闭，A就可以关闭连接了。

> 原文链接：https://blog.csdn.net/qq_38542085/article/details/91820528

**可以理解为：**

A：我没东西发了，关了哦

B：好，但我还有东西没发完

B：我也好了，我也关了哦

A：嗯嗯你关吧

B收到后（关闭链接）

A等待2MSL后（关闭连接）

![image-20211121225404181](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211121225404.png)

**为什么TCP要四次挥手?**

1. TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。
2. TCP是全双工模式，主机1请求关闭连接，不再发送数据了，但是可以接收主机2的数据，主机2不再发送数据了，才算关闭，这样减小了丢失数据的风险。



# 应用层

## 域名系统DNS

将便于使用的机器名字改为IP地址

大多数名字在本地解析，少量需要在互联网上通信，所以效率高

![image-20211122214008765](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211122214015.png)

域名格式要求：

1. 每一个符号不超过63个字符（为方便记忆，最好不要超过12个字符）
2. 不区分大小写
3. 除了连字符（-）外不能使用标点符号
4. 由多个标号组成的完整域名总共不超过255个字符

各级域名由上一级的域名管理机构管理

![image-20211122215222585](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211122215222.png)

DNS服务器以`区`为单位，`区`小于等于 `域`

![image-20211122220600307](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211122220600.png)

下图每一个域名服务器都能进行部分域名到IP地址的解析

当某个DNS服务器不能进行域名到IP地址的转换时，他会设法找互联网上别的域名服务器进行解析

![image-20211123205215610](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211123205222.png)

每个域名服务器只对域名体系中的一部分进行管辖

根据域名所起的作用，可以把域名服务器划分为四种类型：

1. 根域名服务器。它并不能将待查询的域名转为IP地址，而是告诉本地域名服务器下一步该找哪一个顶级服务器进行查询
2. 顶级域名服务器。管理所有二级域名
3. 权限域名服务器。就是上图负责一个区的服务器
4. 本地域名服务器。本机向本地域名服务器查询一般采用递归查询，而本地域名服务器向根域名服务器查询则通常采用迭代查询

![image-20211123215541541](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211123215541.png)

上图（a）的查询步骤：

![image-20211123220706658](https://raw.githubusercontent.com/LShang233/mdImg/master/img/20211123220706.png)

